{
  try {
    is=socket.getInputStream();
    if (is == null)     return;
    byte[] buf=new byte[bufsize];
    int rlen=is.read(buf,0,bufsize);
    if (rlen <= 0)     return;
    ByteArrayInputStream hbis=new ByteArrayInputStream(buf,0,rlen);
    BufferedReader hin=new BufferedReader(new InputStreamReader(hbis,"utf-8"));
    Properties pre=new Properties();
    Properties parms=new Properties();
    Properties header=new Properties();
    Properties files=new Properties();
    decodeHeader(hin,pre,parms,header);
    Log.d("Streamer",pre.toString());
    Log.d("Streamer","Params: " + parms.toString());
    Log.d("Streamer","Header: " + header.toString());
    String method=pre.getProperty("method");
    String uri=pre.getProperty("uri");
    long size=0x7FFFFFFFFFFFFFFFl;
    String contentLength=header.getProperty("content-length");
    if (contentLength != null) {
      try {
        size=Integer.parseInt(contentLength);
      }
 catch (      NumberFormatException ex) {
      }
    }
    int splitbyte=0;
    boolean sbfound=false;
    while (splitbyte < rlen) {
      if (buf[splitbyte] == '\r' && buf[++splitbyte] == '\n' && buf[++splitbyte] == '\r' && buf[++splitbyte] == '\n') {
        sbfound=true;
        break;
      }
      splitbyte++;
    }
    splitbyte++;
    ByteArrayOutputStream f=new ByteArrayOutputStream();
    if (splitbyte < rlen)     f.write(buf,splitbyte,rlen - splitbyte);
    if (splitbyte < rlen)     size-=rlen - splitbyte + 1;
 else     if (!sbfound || size == 0x7FFFFFFFFFFFFFFFl)     size=0;
    buf=new byte[512];
    while (rlen >= 0 && size > 0) {
      rlen=is.read(buf,0,512);
      size-=rlen;
      if (rlen > 0)       f.write(buf,0,rlen);
    }
    byte[] fbuf=f.toByteArray();
    ByteArrayInputStream bin=new ByteArrayInputStream(fbuf);
    BufferedReader in=new BufferedReader(new InputStreamReader(bin));
    if (method.equalsIgnoreCase("POST")) {
      String contentType="";
      String contentTypeHeader=header.getProperty("content-type");
      StringTokenizer st=new StringTokenizer(contentTypeHeader,"; ");
      if (st.hasMoreTokens()) {
        contentType=st.nextToken();
      }
      if (contentType.equalsIgnoreCase("multipart/form-data")) {
        if (!st.hasMoreTokens())         sendError(socket,HTTP_BADREQUEST,"BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html");
        String boundaryExp=st.nextToken();
        st=new StringTokenizer(boundaryExp,"=");
        if (st.countTokens() != 2)         sendError(socket,HTTP_BADREQUEST,"BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html");
        st.nextToken();
        String boundary=st.nextToken();
        decodeMultipartData(boundary,fbuf,in,parms,files);
      }
 else {
        String postLine="";
        char pbuf[]=new char[512];
        int read=in.read(pbuf);
        while (read >= 0 && !postLine.endsWith("\r\n")) {
          postLine+=String.valueOf(pbuf,0,read);
          read=in.read(pbuf);
          if (Thread.interrupted()) {
            in.close();
            throw new InterruptedException();
          }
        }
        postLine=postLine.trim();
        decodeParms(postLine,parms);
      }
    }
    Response r=serve(uri,method,header,parms,files);
    if (r == null)     sendError(socket,HTTP_INTERNALERROR,"SERVER INTERNAL ERROR: Serve() returned a null response.");
 else     sendResponse(socket,r.status,r.mimeType,r.header,r.data);
    in.close();
  }
 catch (  IOException ioe) {
    try {
      sendError(socket,HTTP_INTERNALERROR,"SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
    }
 catch (    Throwable t) {
    }
  }
catch (  InterruptedException ie) {
  }
}
